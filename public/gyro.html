<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giro</title>
    <style>
        html, body {
            box-sizing: border-box;
        }
        canvas {
            border-style: solid;
        }
    </style>
</head>
<body>
    <h4 id="raw-input"></h4>
    <canvas></canvas>
    <h1 id="x-axis"></h1>
    <h1 id="y-axis"></h1>
    <h1 id="z-axis"></h1>
</body>
<script src="/socket.io/socket.io.js"></script>
<script>
    const domain = (new URL(window.location.href));
    const socket = io(domain.origin);
    
    socket.on("connect", () => {
        socket.emit("purpose", "giro-display")
    })
</script>
<script>
    const canvas = document.querySelector("canvas")
    canvas.height = 600
    canvas.width = 600
    const c = canvas.getContext("2d")
    const rawInput = document.getElementById("raw-input")
    const xAxis = document.getElementById("x-axis")
    const yAxis = document.getElementById("y-axis")
    const zAxis = document.getElementById("z-axis")
</script>
<script>
    class Gage {
        constructor (name, index, fillColor = "black", tressholdColor = "red") {
            this.visualMultiplier = 1
            this.fColor = fillColor
            this.tColor = tressholdColor
            this.name = name
            this.value = 0
            this.tresshold = 0
            this.width = 80
            this.x = index * this.width
            this.y = canvas.width / 2
            this.font = "20px Arial"
        } 

        setTresshold = ( value ) => this.tresshold = value * this.visualMultiplier;

        updateValue = ( value ) => {
            this.value = value * this.visualMultiplier
            this.drawGage()
            this.drawName()
            this.drawTresshold()
        }

        drawGage () {
            c.fillStyle = this.fColor;
            c.fillRect(this.x, this.y, this.width, this.value);
        }

        drawTresshold() {
            c.strokeStyle = this.tColor;
            c.beginPath()
            c.moveTo(this.x, this.y + this.tresshold * this.visualMultiplier)
            c.lineTo(this.x  + this.width, this.y + this.tresshold * this.visualMultiplier)
            c.moveTo(this.x,this.y - this.tresshold * this.visualMultiplier)
            c.lineTo(this.x  + this.width, this.y +  this.tresshold * this.visualMultiplier)
            c.stroke()
        }

        drawName() {
            c.font = this.font;
            c.fillText(this.name, this.x, 20)
        }
    }
</script>
<script>
    
    socket.on("raw-gyro-data", (data) => {
        const { Gx, Gy, Gz, Ax, Ay, Az} = data
        rawInput.innerHTML = `Gx: ${Gx} Gy: ${Gy} Gz: ${Gz} Ax: ${Ay} Ay: ${Ay} Az: ${Az}`
        drawValues(data)
        updateGiroPos(data)
    })

    let tressholdSet = false
    let gages = undefined

    socket.on("gyro-state", state => {
        if(gages === undefined) createGages( state.angles )
        else {
            c.fillStyle ="white"
            c.fillRect(0,0, canvas.width, canvas.height)

            Object.entries(state.angles).forEach(([key, value]) => {
                gages[key].updateValue(value)
            })
        }

        if(tressholdSet === false){
            if(state.tresshold !== undefined){
                // console.log(state.tresshold)
                Object.entries(state.tresshold).forEach(([key, value]) => {
                    gages[key].setTresshold(value)
                })
            }
        }
    })

    function createGages (state) {
        gages = {}
        Object.entries(state).forEach(([key,value], index) => {
            const gage = new Gage(key, index)
            gages[key] = gage;
        })
        console.log(gages)
    }

    // function updateGiroPosDisplay (x, y, z) {
    //     xAxis.innerHTML = "X Axis: " + x;
    //     yAxis.innerHTML = "Y Axis: " + y;
    //     zAxis.innerHTML = "Z Axis: " + z;
    // }

    function removeAllChildNodes(parent) {
        while (parent.firstChild) {
            parent.removeChild(parent.firstChild);
        }
    }
</script>
</html>